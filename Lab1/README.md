# Лабораторная 1. Сортировки, куча, бинпоиск

## A. Простая сортировка

В этой задаче вам нужно реализовать любую из пройденных сортировок, работающих за время **O(nlogn)**.
Использовать встроенные в язык сортировки и структуры данных запрещается.

Дан массив целых чисел. Ваша задача — отсортировать его в порядке неубывания.

* **Входные данные:**
В первой строке содержится число **n (1⩽n⩽100000)** — количество элементов в массиве.
Во второй строке находятся **n** целых чисел, по модулю не превосходящих **10<sup>9</sup>**.

* **Выходные данные:**
Выведите этот же массив в порядке неубывания.

### Пример

* **Входные данные:**

      10
      1 8 2 1 4 7 3 2 3 6

* **Выходные данные:**

      1 1 2 2 3 3 4 6 7 8 

#### [&решение](https://github.com/Ma-XD/Alg-and-Data-Str/blob/main/Lab1/src/SimpleSort.java)

## B. Сортировка подсчетом

А в этой задаче вам нужно реализовать сортировку подсчетом. Использовать другие сортировки запрещается.

Дан массив из **n** элементов, которые принимают целые значения от **0** до **100**. Отсортируйте этот массив в порядке неубывания элементов.

* **Входные данные:**
В первой строке содержится число **n (1≤n≤200000)** — количество элементов в массиве.
Во второй строке находятся **n** целых чисел, от **0** до **100** каждое.

* **Выходные данные:**
Выведите отсортированный массив.

### Пример

* **Входные данные:**

      5
      7 3 4 2 5

* **Выходные данные:**

      2 3 4 5 7 

#### [&решение](https://github.com/Ma-XD/Alg-and-Data-Str/blob/main/Lab1/src/CountSort.java)

## C. Количество инверсий

Напишите программу, которая для заданного массива **A=⟨a1,a2,…,an⟩** находит количество пар **(i,j)** таких, что **i<j** и **ai>aj**.

* **Входные данные:**
Первая строка входного файла содержит натуральное число **n (1≤n≤500000**) — количество элементов массива.
Вторая строка содержит **n** попарно различных элементов массива **A (0≤ai≤10<sup>6</sup>)**.

* **Выходные данные:**
В выходной файл выведите одно число — ответ на задачу.

### Примеры

* **Входные данные:**

      4
      1 2 4 5

* **Выходные данные:**

      0

___

* **Входные данные:**

      4
      5 4 2 1

* **Выходные данные:**

      6

#### [&решение](https://github.com/Ma-XD/Alg-and-Data-Str/blob/main/Lab1/src/NumberOfInversions.java)

## D. Хипуй!

В этой задаче вам необходимо организовать структуру данных Heap для хранения целых чисел, над которой определены следующие операции:

* `Insert(X)` — добавить в Heap число **X**;
* `Extract` — достать из Heap наибольшее число (удалив его при этом).
Эту задачу нужно решить без использования встроенных структур данных для поиска максимального числа.

* **Входные данные:**
Во входном файле записано количество команд **n (1≤n≤100000)**, потом последовательность из **n** команд, каждая в своей строке.
Каждая команда имеет такой формат: **"0 <число>"** или **"1"**, что означает соответственно операции `Insert(<число>)` и `Extract`. Добавляемые числа находятся в интервале от **1** до **10<sup>7</sup>** включительно.
Гарантируется, что при выполнении команды `Extract` в структуре находится по крайней мере один элемент.

* **Выходные данные:**
В выходной файл для каждой команды извлечения необходимо вывести число, полученное при выполнении команды `Extract`.

### Пример

* **Входные данные:**

      7
      0 100
      0 10
      1
      0 5
      0 30
      0 50
      1

* **Выходные данные:**

      100
      50

#### [&решение](https://github.com/Ma-XD/Alg-and-Data-Str/blob/main/Lab1/src/Heap.java)

## E. Быстрый поиск в массиве

Дан массив из n целых чисел. Все числа от **−10<sup>9</sup>** до **10<sup>9</sup>**.

Нужно уметь отвечать на запросы вида «Cколько чисел имеют значения от **l** до **r**»?

* **Входные данные:**
Число **n (1≤n≤10<sup>5</sup>)**. Далее **n** целых чисел.
Затем число запросов **k (1≤k≤10<sup>5</sup>)**.
Далее **k** пар чисел **l,r (−10<sup>9</sup>≤l≤r≤10<sup>9</sup>)** — собственно запросы.

* **Выходные данные:**
Выведите **k** чисел — ответы на запросы.

### Пример

* **Входные данные:**

      5
      10 1 10 3 4
      4
      1 10
      2 9
      3 4
      2 2

* **Выходные данные:**

      5 2 2 0 

#### [&решение](https://github.com/Ma-XD/Alg-and-Data-Str/blob/main/Lab1/src/QuickSearchInArray.java)

## F. Приближенный двоичный поиск

Даны два массива. Первый массив отсортирован по неубыванию, второй массив содержит запросы — целые числа.

Для каждого запроса выведите число из первого массива наиболее близкое (то есть с минимальным модулем разности) к числу в этом запросе . Если таких несколько, выведите меньшее из них.

* **Входные данные:**
В первой строке входных данных содержатся числа **n** и **k (0<n, k≤10<sup>5</sup>)**.
Во второй строке задаются **n** чисел первого массива, отсортированного по неубыванию, а в третьей строке — **k** чисел второго массива.
Каждое число в обоих массивах по модулю не превосходит **2·10<sup>9</sup>** .

* **Выходные данные:**
Для каждого из **k** чисел выведите в отдельную строку число из первого массива, наиболее близкое к данному. Если таких несколько, выведите меньшее из них.

### Пример

* **Входные данные:**

      5 5
      1 3 5 7 9
      2 4 8 1 6

* **Выходные данные:**

      1
      3
      7
      1
      5

#### [&решение](https://github.com/Ma-XD/Alg-and-Data-Str/blob/main/Lab1/src/ApproximateBinarySearch.java)

## G. Очень Легкая Задача

Сегодня утром жюри решило добавить в вариант олимпиады еще одну, Очень Легкую Задачу. Ответственный секретарь Оргкомитета напечатал ее условие в одном экземпляре, и теперь ему нужно до начала олимпиады успеть сделать еще **n** копий. В его распоряжении имеются два ксерокса, один из которых копирует лист за **x** секунд, а другой — за **y**. (Разрешается использовать как один ксерокс, так и оба одновременно. Можно копировать не только с оригинала, но и с копии.) Помогите ему выяснить, какое минимальное время для этого потребуется.

* **Входные данные:**
На вход программы поступают три натуральных числа **n**, **x** и **y**, разделенные пробелом **(1≤n≤2·10<sup>8</sup>, 1≤x, y≤10)**.

* **Выходные данные:**
Выведите одно число — минимальное время в секундах, необходимое для получения **n** копий.

### Примеры

* **Входные данные:**

      4 1 1

* **Выходные данные:**

      3

___

* **Входные данные:**

      5 1 2

* **Выходные данные:**

      4

#### [&решение](https://github.com/Ma-XD/Alg-and-Data-Str/blob/main/Lab1/src/VeryEasyTask.java)

## H. Дипломы

Когда Петя учился в школе, он часто участвовал в олимпиадах по информатике, математике и физике. Так как он был достаточно способным мальчиком и усердно учился, то на многих из этих олимпиад он получал дипломы. К окончанию школы у него накопилось **n** дипломов, причём, как оказалось, все они имели одинаковые размеры: **w** — в ширину и **h** — в высоту.

Сейчас Петя учится в одном из лучших российских университетов и живёт в общежитии со своими одногруппниками. Он решил украсить свою комнату, повесив на одну из стен свои дипломы за школьные олимпиады. Так как к бетонной стене прикрепить дипломы достаточно трудно, то он решил купить специальную доску из пробкового дерева, чтобы прикрепить её к стене, а к ней — дипломы. Для того чтобы эта конструкция выглядела более красиво, Петя хочет, чтобы доска была квадратной и занимала как можно меньше места на стене. Каждый диплом должен быть размещён строго в прямоугольнике размером **w** на **h**. Дипломы запрещается поворачивать на 90 градусов. Прямоугольники, соответствующие различным дипломам, не должны иметь общих внутренних точек.

Требуется написать программу, которая вычислит минимальный размер стороны доски, которая потребуется Пете для размещения всех своих дипломов.

* **Входные данные:**
Входной файл содержит три целых числа: **w, h, n (1⩽w,h,n⩽10<sup>9</sup>)**.

* **Выходные данные:**
В выходной файл необходимо вывести ответ на поставленную задачу.

### Пример

* **Входные данные:**

      2 3 10

* **Выходные данные:**

      9

#### [&решение](https://github.com/Ma-XD/Alg-and-Data-Str/blob/main/Lab1/src/Diplomas.java)

## I. Квадратный корень и квадратный квадрат

Найдите такое число **x**, что **x<sup>2</sup>+√x=C**, с точностью не менее 6 знаков после точки.

* **Входные данные:**
В единственной строке содержится вещественное число **1.0≤C≤10<sup>10</sup>**.

* **Выходные данные:**
Выведите одно число — искомый **x**.

### Примеры

* **Входные данные:**

      2.0000000000

* **Выходные данные:**

      1.0

___

* **Входные данные:**

      18.0000000000

* **Выходные данные:**

      4.0

#### [&решение](https://github.com/Ma-XD/Alg-and-Data-Str/blob/main/Lab1/src/SquareRootAndSquare.java)

## J. Поляна дров

Маленький мальчик Фермa живет в деревне. Наступают холодные времена, поэтому бабушка попросила мальчика сходить в лес, чтобы собрать дров. В лесу около деревни, в которой живет Ферма, находится волшебная Поляна Дров, на которой всегда лежат дрова, и никогда не кончаются. Естественно, Ферма должен пойти именно туда.

Единственная проблема заключается в том, что идти до Поляны не очень близко, тем более что скорость передвижения по лесу намного меньше, чем скорость передвижения по полю, в котором находится деревня.

* Деревня находится в точке с координатами  **(0,1)**.
* Поляна находится в точке с координатами  **(1,0)**.
* Граница между лесом и полем — горизонтальная прямая **y=a**, где **a** — некоторое число **(0⩽a⩽1**).
* Скорость передвижения по полю составляет **Vp**, скорость передвижения по лесу — **Vf**. Вдоль границы можно двигаться как по лесу, так и по полю.

Найдите точку, в которой мальчик Ферма должен войти в лес, чтобы дойти до Поляны Дров как можно быстрее.

* **Входные данные:**
В первой строке входного файла содержатся два положительных целых числа — **Vp** и **Vf (1⩽Vp, Vf⩽10<sup>10</sup>)**. Во второй строке содержится единственное вещественное число — координата по оси **Oy** границы между лесом и полем **a (0⩽a⩽1)**

* **Выходные данные:**
В единственной строке выходного файла выведите вещественное число с точностью не менее 4 знаков после запятой — координата по оси **Ox** точки, в которой мальчик Ферма должен войти в лес.

### Пример

* **Входные данные:**

      5 3
      0.4

* **Выходные данные:**

      0.783310604

#### [&решение](https://github.com/Ma-XD/Alg-and-Data-Str/blob/main/Lab1/src/GladeOfFirewood.java)

## K. Разделение массива

Дан массив из **n** положительных целых чисел. Нужно разбить его на **k** отрезков так, чтобы максимальная сумма на отрезке была минимально возможной.

* **Входные данные:**
Первая строка содержит целые числа **n** и **k (1≤k≤n≤10<sup>5</sup>)**.
Вторая строка содержит элементы массива **ai (1≤ai≤10<sup>9</sup>)**.

* **Выходные данные:**
Выведите одно число — минимально возможную максимальную сумму на отрезке.

### Пример

* **Входные данные:**

      10 4
      1 3 2 4 10 8 4 2 5 3

* **Выходные данные:**

      12

#### [&решение](https://github.com/Ma-XD/Alg-and-Data-Str/blob/main/Lab1/src/SplittingArray.java)
